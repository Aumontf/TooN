<HTML>
<!-- T.W. Drummond -->

<HEAD>
<TITLE> CUED home page - Dr T.W. Drummond </TITLE>
<!-- Changed by: T.W. Drummond, 16-Aug-1999 -->
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000A3" VLINK="#760076" ALINK="#FF0000">

<A HREF="http://www.cam.ac.uk">
   <IMG align=left BORDER=0 ALT="[Univ of Cambridge]"
    SRC="http://www.eng.cam.ac.uk/images/house_style/uniban-s.gif"></A>
<A HREF="http://www.eng.cam.ac.uk">
   <IMG align=
right BORDER=0 ALT="[Dept of Engineering]"
    SRC="http://www.eng.cam.ac.uk/images/house_style/engban-s.gif"></A>
<Br>
<Br>
<Br>
<HR>

<H2>Return value optimisation vs Lazy evaluation</H2>

When you write:
<br>
<br> <tt> v1 = M * v2; </tt> &nbsp;&nbsp;&nbsp;&nbsp; (1)
<br>
<br> A naive implementation will compute M * v2 and store the result in a temporary object.  It will then
copy this temporary object into v1.  A method often advanced to avoid this is to have M * v2 simply return
an special object O which contains references to M and v2.  When the compiler then resolves v1 = O, the
special object computes M*v2 directly into v1.  This approach is often called lazy evaluation and the
special objects lazy vectors or lazy matrices.  Stroustrup (The C++ programming language Chapter 22) refers
to them as composition closure objects or compositors.
<br>
<br> The killer is this: &nbsp;&nbsp;&nbsp;&nbsp; <b> What if v1 is just another name for v2? </b>
<br>
<br> i.e. you write something like &nbsp;&nbsp;&nbsp;&nbsp; <tt> v = M * v; </tt>
<br> 
<br> In this case the semantics have been broken because the values of v are being overwritten as the
computation progresses and then the remainder of the computation is using the new values.  In this libarary
v1 in expression (1) could equally well alias part of M, thus you can't even solve the problem by having
a clever check for aliasing between v1 and v2.  This aliasing problem means that the only time the
compiler can assume it's safe to omit the temporary is when v1 is being constructed (and thus cannot alias
anything else):
<br>
<br> <tt> Vector<3> v1 = M * v2; </tt>
<br>
<br> TooN provides this optimisation by providing the compiler with the opportunity to use a return value
optimisation.  It does this by making M * v2 call a special constructor for <tt> Vector<3> </tt> with
M and v2 as arguments.  Since nothing is happening between the construction of the temporary and the
copy construction of v1 from the temporary (which is then destroyed), the compiler is permitted to
optimise the construction of the return value directly into v1.
<br>
<br> Because a naive implemenation of this strategy would result in the vector and matrix classes having a very
large number of constructors, these classes are provided with template constructors that take a standard form.
The code that does this, declared in the header of class Vector is:
<br>
<br> <tt>  <b> // constructor from 2-ary operator </b>
<br> template &lt;class LHS, class RHS, class Op&gt;
<br> inline Vector(const LHS& lhs, const RHS& rhs, const Operator&lt;Op&gt;&){Op::eval(*this,lhs,rhs);}
<br>
<br> The third argument of the constructor is a dummy, used to specify the construction method because you
the standard doesn't allow you to supply template arguments when you call a constructor.  Since the
argument is unused, my compiler omits it (and I hope yours does too).

<br>
<br>
<br>
<br>
<!-- Change the next line to Updated: {date when updated} -->
Updated: Tue 19 Aug 2002 
<ADDRESS>T.W. Drummond - <A HREF="mailto:twd20@eng.cam.ac.uk">twd20@eng.cam.ac.uk</A></ADDRESS>
</BODY>
</HTML>
