#ifndef __VACCESSOR_HH
#define __VACCESSOR_HH


///////////////////////////////
//                           //
//  Vector Accessor classes  //
//                           //
///////////////////////////////

/////////////  FIXED SIZED ACCESSORS ////////////////





template <int Size, class AllocZone>
class FixedVAccessor : public AllocZone {
 public:
  inline const double& operator[] (int i)const 
  {
    return my_values[i];
  }

  inline double& operator[] (int i) 
  {
    return my_values[i];
  }


  inline static int size() {return Size;}

  template<int Start, int Length>
  inline FixedVector<Length,FixedVAccessor<Length,Stack<Length> > >& slice() 
  {
    return reinterpret_cast<FixedVector<Length,FixedVAccessor<Length,Stack<Length> > >&> (my_values[Start]);
  }

  
  template<int Start, int Length>
  inline const FixedVector<Length,FixedVAccessor<Length,Stack<Length> > >& slice() const 
  {
    return reinterpret_cast<const FixedVector<Length,FixedVAccessor<Length,Stack<Length> > >&> (my_values[Start]);
  }

  // convert to Matrices
  inline FixedMatrix<Size,1,FixedMAccessor<Size,1,ColMajor,Stack<Size> > >& as_col() throw()
  {
    return reinterpret_cast<FixedMatrix<Size,1,FixedMAccessor<Size,1,ColMajor,Stack<Size> > >&>(*my_values);
  }

  inline const FixedMatrix<Size,1,FixedMAccessor<Size,1,ColMajor,Stack<Size> > >& as_col() const throw()
  {
    return reinterpret_cast<const FixedMatrix<Size,1,FixedMAccessor<Size,1,ColMajor,Stack<Size> > >&> (*my_values);
  }

  inline FixedMatrix<1,Size,FixedMAccessor<1,Size,RowMajor,Stack<Size> > >& as_row() throw()
  {
    return reinterpret_cast<FixedMatrix<1,Size,FixedMAccessor<1,Size,RowMajor,Stack<Size> > >&> (*my_values);
  }
  
  inline const FixedMatrix<1,Size,FixedMAccessor<1,Size,RowMajor,Stack<Size> > >& as_row() const throw()
  {
    return reinterpret_cast<const FixedMatrix<1,Size,FixedMAccessor<1,Size,RowMajor,Stack<Size> > >&> (*my_values);
  }
  
};


template <int Size, int Skip>
class SkipAccessor : public Stack<Size*Skip>{
 public:
  inline const double& operator[] (int i) const  
  {
	return my_values[i*Skip];
  }

  inline double& operator[] (int i) 
  {
	return my_values[i*Skip];
  }

  inline static int size() throw()
  {
    return Size;
  }

  template<int Start, int Length>
  inline FixedVector<Size, SkipAccessor<Size, Skip> >& slice() 
  {
	return reinterpret_cast<FixedVector<Size, SkipAccessor<Size, Skip> >&>(my_values[Start*Skip]);
  }

  template<int Start, int Length>
  inline const FixedVector<Size, SkipAccessor<Size, Skip> >& slice() const 
  {
    return reinterpret_cast<const FixedVector<Size, SkipAccessor<Size, Skip> >&>(my_values[Start*Skip]);
  }

  // convert to Matrices
  inline FixedMatrix<Size,1,SkipMAccessor<Size,1,Skip,RowMajor> >& as_col() throw()
  {
    return reinterpret_cast<FixedMatrix<Size,1,SkipMAccessor<Size,1,Skip,RowMajor> >&>(*my_values);
  }

  inline const FixedMatrix<Size,1,SkipMAccessor<Size,1,Skip,RowMajor> >& as_col() const throw()
  {
    return reinterpret_cast<FixedMatrix<Size,1,SkipMAccessor<Size,1,Skip,RowMajor> >&>(*my_values);
  }

  inline FixedMatrix<1,Size,SkipMAccessor<1,Size,Skip,ColMajor> >& as_row() throw()
  {
    return reinterpret_cast<FixedMatrix<1,Size,SkipMAccessor<1,Size,Skip,ColMajor> >&>(*my_values);
  }

  inline const FixedMatrix<1,Size,SkipMAccessor<1,Size,Skip,ColMajor> >& as_row() const throw()
  {
    return reinterpret_cast<const FixedMatrix<1,Size,SkipMAccessor<1,Size,Skip,ColMajor> >&>(*my_values);
  }

};

/////////////  DYNAMIC SIZED ACCESSORS ////////////////




class DynamicVAccessor {
  friend class VSizer;
 public:
  template<int Start, int Length>
  inline FixedVector<Length, FixedVAccessor<Length, Stack<Length> > >& slice() 
  {
    return reinterpret_cast<FixedVector<Length, FixedVAccessor<Length, Stack<Length> > >&> (my_values[Start]);
  }

  template<int Start, int Length>
  const inline FixedVector<Length, FixedVAccessor<Length, Stack<Length> > >& slice() const 
  {
    return reinterpret_cast<const FixedVector<Length, FixedVAccessor<Length, Stack<Length> > >&> (my_values[Start]);
  }

  inline const double& operator[] (int i)const 
  {
    return my_values[i];
  }

  inline double& operator[] (int i) 
  {
    return my_values[i];
  }

  inline int size() const throw()
  {
    return my_size;
  }

  inline RefMatrix<RowMajor> as_row(); // implemented in linoperators.hh
  inline RefMatrix<ColMajor> as_col(); //

 protected:
  int my_size;
  double* my_values;
};

class DynamicSkipAccessor{
 public:

  //CHECK THIS
  template<int Start, int Length>
  inline DynamicSkipAccessor slice() 
  {
    //DynamicSkipAccessors do not own memory, so destruction of one will not free it 
	
	DynamicSkipAccessor r;
	r.size = Length;
	r.my_skip = my_skip;
	r.my_values = my_values + my_skip * Start;
	
	return r;
  }

  inline const double& operator[] (int i)const 
  {
    return my_values[i*my_skip];
  }

  inline double& operator[] (int i) 
  {
    return my_values[i*my_skip];	
  }
  
  inline int size() const throw()
  {
    return my_size;
  }

  inline RefSkipMatrix<ColMajor> as_row(); // implemented in linoperators.hh
  inline RefSkipMatrix<RowMajor> as_col(); //


 protected:
  int my_size;
  int my_skip;
  double* my_values;
};

#endif
